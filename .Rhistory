print(tabla_resultados)
# -------------------------------------------------------------
# 4) ESTIMADOR DE MÁXIMA VEROSIMILITUD (EMV / MLE)
# -------------------------------------------------------------
indice_max <- which.max(likelihoods)
EMV_A <- A_vals[indice_max]
EMV_theta <- theta_vals[indice_max]
L_max <- likelihoods[indice_max]
cat("\n====================================================\n")
cat("                 RESULTADO DEL EMV\n")
cat("====================================================\n")
cat("Valor observado: x =", x_obs, "\n")
cat("EMV de A:", EMV_A, "\n")
cat("EMV de theta:", EMV_theta, "\n")
cat("Verosimilitud máxima:", L_max, "\n")
cat("====================================================\n\n")
# -------------------------------------------------------------
# 5) GRÁFICA DE LA FUNCIÓN DE VEROSIMILITUD
# -------------------------------------------------------------
plot(theta_vals, likelihoods, type = "h", lwd = 5, col = "black",
main = "Función de Verosimilitud L(theta) - Distribución V",
xlab = expression(theta), ylab = "L(theta)")
points(EMV_theta, L_max, pch = 19, cex = 2, col = "hotpink")
text(EMV_theta, L_max, labels = paste("EMV =", EMV_theta), pos = 3, col = "red")
# -------------------------------------------------------------
# 5) GRÁFICA DE LA FUNCIÓN DE VEROSIMILITUD
# -------------------------------------------------------------
plot(theta_vals, likelihoods, type = "h", lwd = 5, col = "black",
main = "Función de Verosimilitud L(theta) - Distribución V",
xlab = expression(theta), ylab = "L(theta)")
points(EMV_theta, L_max, pch = 19, cex = 2, col = "hotpink")
text(EMV_theta, L_max, labels = paste("EMV =", EMV_theta), pos = 3, col = "red")
cat("EMV de A:", EMV_A, "\n")
cat("EMV de theta:", EMV_theta, "\n")
cat("Verosimilitud máxima:", L_max, "\n")
# 1) PARÁMETROS DEL PROBLEMA
N <- 8              # tamaño de la población
n <- 4              # tamaño de la muestra
x_obs <- 2          # valor observado de X
# Espacio paramétrico
theta_vals <- seq(0, 1, by = 1/8)   # 0, 1/8, ..., 1
A_vals <- N * theta_vals            # Número de éxitos en población: 0,1,...,8
# -------------------------------------------------------------
# 2) FUNCIÓN DE MASA DE PROBABILIDAD - DISTRIBUCIÓN V
# Fórmula: P(X=x) = [C(A+x-1, x) * C(N-A+n-x-1, n-x)] / C(N+n-1, n)
# -------------------------------------------------------------
pmf_V <- function(A, N, n, x){
if(A < 0 || A > N) return(0)
a1 <- A + x - 1
a2 <- x
b1 <- (N - A) + (n - x) - 1
b2 <- n - x
if(a1 < a2 || b1 < b2) return(0)
if(a2 < 0 || b2 < 0) return(0)
num1 <- choose(a1, a2)
num2 <- choose(b1, b2)
den  <- choose(N + n - 1, n)
return((num1 * num2) / den)
}
# -------------------------------------------------------------
# 3) CÁLCULO DE VEROSIMILITUDES
# -------------------------------------------------------------
likelihoods <- sapply(A_vals, pmf_V, N = N, n = n, x = x_obs)
# Tabla de resultados mejorada
resultados <- data.frame(
Theta = theta_vals,
A = A_vals,
L_Theta = round(likelihoods, 6),
L_Relativa = round(likelihoods / max(likelihoods), 4)
)
print("Tabla de Verosimilitudes:")
print(resultados)
cat("\n")
# -------------------------------------------------------------
# 4) ESTIMACIÓN MÁXIMO VEROSÍMIL
# -------------------------------------------------------------
ind_max <- which.max(likelihoods)
EMV_A <- A_vals[ind_max]
EMV_theta <- theta_vals[ind_max]
L_max <- likelihoods[ind_max]
cat("══════════════════════════════════════════════════════\n")
cat("           ESTIMACIÓN POR MÁXIMA VEROSIMILITUD\n")
cat("══════════════════════════════════════════════════════\n")
cat("• Población total (N) =", N, "porciones\n")
cat("• Muestra tomada (n) =", n, "porciones\n")
cat("• Valor observado (x) =", x_obs, "\n")
cat("• Distribución: V (muestreo con reemplazo)\n")
cat("• EMV de A =", EMV_A, "\n")
cat("• EMV de θ =", EMV_theta, "\n")
cat("• Máxima verosimilitud =", round(L_max, 6), "\n")
cat("══════════════════════════════════════════════════════\n\n")
# -------------------------------------------------------------
# 5) GRÁFICO
# -------------------------------------------------------------
par(mfrow = c(1, 1), mar = c(5, 4, 4, 2))
plot(theta_vals, likelihoods,
type = "h",
lwd = 8,
col = "steelblue",
lend = 2,
xlab = expression(theta),
ylab = "L(θ)",
main = expression("Función de Verosimilitud L(θ) para X ~ V(N=8, n=4, x=2)"),
cex.main = 0.9,
ylim = c(0, max(likelihoods) * 1.1))
# Punto del EMV
points(EMV_theta, L_max,
pch = 21,
bg = "gold",
col = "darkred",
cex = 2,
lwd = 2)
# Texto del EMV
text(EMV_theta, L_max,
labels = paste("EMV =", EMV_theta),
pos = 3,
col = "darkred",
font = 2)
# Líneas de guía
abline(v = EMV_theta, col = "orange", lty = 2, lwd = 1.5)
abline(h = L_max, col = "orange", lty = 2, lwd = 1.5)
knitr::opts_chunk$set(echo = TRUE)
# 1. UNA SOLA BASE DE DATOS ORIGINAL (n = 1000)
set.seed(123)
alpha_true <- 2
beta_true <- 3
n <- 1000
reclamos <- alpha_true / (1 - runif(n))^(1/beta_true)
# 1. Valor observado del mínimo
alpha_EMV_observado <- min(reclamos)
# 2. Valor esperado teórico del mínimo
E_alpha_EMV_teorico <- (n * beta_true * alpha_true) / (n * beta_true - 1)
print(paste("El valor observado es:", alpha_EMV_observado, "y el valor esperado es:", E_alpha_EMV_teorico))
# =============================================================================
# DEMOSTRACIÓN VISUAL: SESGO POSITivo Y CONVERGENCIA ASINTÓTICA
# =============================================================================
# 1. UNA SOLA BASE DE DATOS ORIGINAL (n = 1000)
set.seed(123)
alpha_true <- 2
beta_true <- 3
n_total <- 1000
reclamos <- alpha_true / (1 - runif(n_total))^(1/beta_true)
# 2. Tamaños de submuestra
n_values <- seq(10, 1000, by = 10)
# 3. Calcular E[α_EMV] teórico para cada n
results <- data.frame(n = n_values)
results$E_teorico <- (results$n * beta_true * alpha_true) / (results$n * beta_true - 1)
# 4. Gráfico de convergencia
library(ggplot2)
ggplot(results, aes(x = n)) +
geom_line(aes(y = E_teorico, color = "E[alfa_EMV] teórico"), linewidth = 1.5) +
geom_hline(yintercept = alpha_true, color = "red", linetype = "dashed", linewidth = 1) +
geom_ribbon(aes(ymin = alpha_true, ymax = E_teorico), fill = "pink", alpha = 0.3) +
labs(
title = "Sesgo Positivo y Convergencia Asintótica de alfa_EMV",
x = "Tamaño de muestra (n)",
y = "Valor esperado E[alfa_EMV]",
color = ""
) +
scale_color_manual(values = c("E[alfa_EMV] teórico" = "blue")) +
theme_minimal() +
annotate("text", x = 500, y = 2.15,
label = "Sesgo positivo: E[alfa_EMV] > alfa",
color = "darkred", size = 4.5, fontface = "bold") +
annotate("text", x = 800, y = 2.02,
label = paste("Límite asintótico: α =", alpha_true),
color = "red", size = 4) +
ylim(1.95, 2.2)
## Aca vemos la var de la muestra total, para ver que es cercana a 0
var_teorica <- (n * beta_true * alpha_true^2) / ((n * beta_true - 1)^2 * (n * beta_true - 2))
var_teorica
# =============================================================================
# GRÁFICO: VARIANZA DE α_EMV TIENDE A CERO
# =============================================================================
# Valores para el gráfico
n_var <- seq(10, 1000, by = 10)
# Varianza teórica de α_EMV
var_teorica <- (n_var * beta_true * alpha_true^2) / ((n_var * beta_true - 1)^2 * (n_var * beta_true - 2))
results_var <- data.frame(n = n_var, varianza = var_teorica)
ggplot(results_var, aes(x = n, y = varianza)) +
geom_line(color = "purple", linewidth = 1.2) +
labs(
title = "Convergencia de la Varianza de alfa_EMV hacia Cero",
subtitle = "Var(alfa_EMV) tiende 0 cuando n tiende inf",
x = "Tamaño de muestra n",
y = "Var(alfa_EMV)"
) +
theme_minimal() +
annotate("text", x = 600, y = max(var_teorica)/2,
label = "Var(alfa_EMV) tiende 0",
color = "purple", size = 5) +
ylim(0, max(var_teorica))
# 1. Valor observado de la media muestral
mu_muestral_obs <- mean(reclamos)
# 2. Valor esperado teórico (mu)
mu_teorico <- (beta_true * alpha_true) / (beta_true - 1)
print(paste("La media muestral observada es:", round(mu_muestral_obs, 5),
"y el valor esperado teórico es:", round(mu_teorico, 5)))
# Simulación de convergencia de la media
n_seq <- seq(10, 1000, by = 10)
medias_n <- sapply(n_seq, function(nn) mean(reclamos[1:nn]))
df_consistencia <- data.frame(n = n_seq, media = medias_n)
ggplot(df_consistencia, aes(x = n, y = media)) +
geom_line(color = "darkgreen") +
geom_hline(yintercept = mu_teorico, linetype = "dashed", color = "red") +
labs(title = "Consistencia de la Media Muestral",
x = "Tamaño de muestra (n)", y = "Media Muestral") +
theme_minimal()
# Usando nuestra base de datos original 'reclamos'
set.seed(123)
alpha_true <- 2
beta_true <- 3
reclamos <- alpha_true / (1 - runif(n))^(1/beta_true)
# 2. Calcular α̂_MM con TU 'reclamos'
alpha_mm_calc <- function(x) {
x_bar <- mean(x)
s <- sd(x)
beta_hat <- 1 + sqrt(1 + (x_bar/s)^2)
return(x_bar * (beta_hat - 1) / beta_hat)
}
alpha_hat_reclamos <- alpha_mm_calc(reclamos)
# 2. Bootstrap simple
set.seed(123)
boot_vals <- replicate(300, {
alpha_mm_calc(sample(reclamos, replace = TRUE))
})
# 3. Gráfico sin abline
hist(boot_vals, col = "lightblue", border = "white",
main = "Distribución de alpha_MM",
xlab = "estimador alpha_MM", ylab = "Frecuencia")
# ----------------------------------------------------------
# SIMULACIÓN Y GRÁFICA DE CONSISTENCIA PARA alpha_MM (Pareto)
# ----------------------------------------------------------
# Parámetros verdaderos
set.seed(123)
alpha_true <- 2
beta_true <- 3
n_max <- 1000
# Generar muestra completa de Pareto
# Método: inversa de la función de distribución acumulada
# F(x) = 1 - (alpha/x)^beta  =>  x = alpha / (1 - u)^(1/beta)
u <- runif(n_max)
reclamos <- alpha_true / (1 - u)^(1/beta_true)
# Función para calcular alpha_MM dada una muestra
calcular_alpha_MM <- function(x) {
n <- length(x)
x_bar <- mean(x)
if (n > 1) {
s2 <- var(x)  # var() usa n-1 en denominador
beta_MM <- 1 + sqrt(1 + (x_bar^2 / s2))
} else {
beta_MM <- NA  # No se puede calcular con n=1
}
alpha_MM <- x_bar * (beta_MM - 1) / beta_MM
return(alpha_MM)
}
# Calcular alpha_MM para diferentes tamaños de muestra
tamanos_muestra <- seq(10, n_max, by = 10)
alpha_estimados <- numeric(length(tamanos_muestra))
for (i in seq_along(tamanos_muestra)) {
n_actual <- tamanos_muestra[i]
muestra <- reclamos[1:n_actual]
alpha_estimados[i] <- calcular_alpha_MM(muestra)
}
# Crear data frame para gráfico
datos_grafico <- data.frame(
n = tamanos_muestra,
alpha_hat = alpha_estimados
)
# ----------------------------------------------------------
# GRÁFICO DE CONSISTENCIA
# ----------------------------------------------------------
library(ggplot2)
ggplot(datos_grafico, aes(x = n, y = alpha_hat)) +
# Línea de los valores estimados
geom_line(color = "steelblue", size = 1) +
# Puntos de los valores estimados
geom_point(color = "steelblue", size = 1.5) +
# Línea horizontal del valor verdadero
geom_hline(yintercept = alpha_true,
color = "red",
linetype = "dashed",
size = 1,
alpha = 0.7) +
# Área de convergencia (+/- 10% del valor verdadero)
geom_ribbon(aes(ymin = alpha_true * 0.9,
ymax = alpha_true * 1.1),
fill = "green",
alpha = 0.1) +
# Etiqueta del valor verdadero
annotate("text",
x = max(tamanos_muestra) * 0.9,
y = alpha_true + 0.05,
label = paste("α verdadero =", alpha_true),
color = "red",
size = 4) +
# Etiqueta de la banda de convergencia
annotate("text",
x = max(tamanos_muestra) * 0.9,
y = alpha_true * 1.05,
label = "Banda ±10%",
color = "darkgreen",
size = 3,
alpha = 0.7) +
# Configuración de ejes y tema
labs(
title = "Consistencia del estimador α̂ (Método de Momentos - Pareto)",
subtitle = paste("α =", alpha_true, ", β =", beta_true, ", n máximo =", n_max),
x = "Tamaño de muestra (n)",
y = expression(hat(alpha)[MM])
) +
scale_x_continuous(breaks = seq(0, n_max, by = 250)) +
scale_y_continuous(
limits = c(min(alpha_estimados, alpha_true * 0.8),
max(alpha_estimados, alpha_true * 1.2)),
breaks = seq(2.9, 3.3, by = 0.1)  # Ajusta según tus datos
) +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, face = "bold"),
plot.subtitle = element_text(hjust = 0.5),
panel.grid.major = element_line(color = "gray90"),
panel.grid.minor = element_blank(),
axis.text = element_text(size = 10),
axis.title = element_text(size = 12)
)
# ----------------------------------------------------------
# ANÁLISIS NUMÉRICO ADICIONAL
# ----------------------------------------------------------
cat("\n=== RESUMEN DE CONVERGENCIA ===\n")
cat("Valor verdadero de α:", alpha_true, "\n")
cat("Última estimación (n =", n_max, "):", alpha_estimados[length(alpha_estimados)], "\n")
cat("Error relativo:",
abs(alpha_estimados[length(alpha_estimados)] - alpha_true) / alpha_true * 100, "%\n")
cat("\nEvolución del error con n:\n")
n_verificar <- c(50, 100, 250, 500, 750, 1000)
for (nv in n_verificar) {
idx <- which(tamanos_muestra == nv)
if (length(idx) > 0) {
error <- abs(alpha_estimados[idx] - alpha_true)
cat(sprintf("n = %4d: α̂ = %.4f, error = %.4f (%.2f%%)\n",
nv, alpha_estimados[idx], error, error/alpha_true*100))
}
}
library(ggplot2)
set.seed(123)
# Datos de comparación
n <- c(30, 50, 100, 200, 500)
LICR <- 2^2/(n*3^2)  # alpha²/(n*beta²)
var_estimada <- LICR * 5.5  # alpha_MM tiene ~5.5 veces más varianza
df <- data.frame(
n = n,
LICR = LICR,
Var_alpha_MM = var_estimada
)
ggplot(df, aes(x = n)) +
geom_line(aes(y = LICR, color = "Límite mínimo (LICR)"), size = 1.5) +
geom_line(aes(y = Var_alpha_MM, color = "Varianza de α̂_MM"), size = 1.5) +
geom_ribbon(aes(ymin = LICR, ymax = Var_alpha_MM),
fill = "red", alpha = 0.1) +
labs(
title = "α̂_MM NO es eficiente",
subtitle = "Su varianza es mucho mayor que el límite mínimo teórico",
x = "Tamaño de muestra (n)",
y = "Varianza",
color = ""
) +
scale_color_manual(values = c("Límite mínimo (LICR)" = "darkgreen",
"Varianza de α̂_MM" = "red")) +
theme_minimal() +
theme(legend.position = "bottom") +
annotate("text", x = 300, y = mean(c(LICR[3], var_estimada[3])),
label = "Área de ineficiencia", color = "red", size = 4)
# ============================================================
# INSesgamiento: SESGO EMPÍRICO DEL ESTIMADOR MM PARA BETA
# ============================================================
set.seed(123)
B <- 3000
n <- length(reclamos)
betaMM_sim <- numeric(B)
for(b in 1:B){
x <- alpha_true / (1 - runif(n))^(1/beta_true)
xbar <- mean(x)
s2   <- var(x)
betaMM_sim[b] <- 1 + sqrt(1 + (xbar^2 / s2))
}
sesgo_betaMM <- mean(betaMM_sim) - beta_true
sesgo_betaMM
library(ggplot2)
df_betaMM <- data.frame(betaMM = betaMM_sim)
ggplot(df_betaMM, aes(x = betaMM)) +
geom_density(fill = "skyblue", alpha = 0.6) +
geom_vline(xintercept = beta_true, linetype = "dashed",
color = "red", linewidth = 1) +
labs(title = "Insesgamiento del Estimador MM para β",
subtitle = "Si fuese insesgado, la distribución estaría centrada
exactamente en β",
x = "Estimaciones de β (MM)",
y = "Densidad") +
theme_minimal()
# ============================================================
# CONSISTENCIA: CONVERGENCIA DEL ESTIMADOR MM
# ============================================================
n_seq <- seq(20, 1000, by = 10)
betaMM_path <- numeric(length(n_seq))
for(i in seq_along(n_seq)){
k <- n_seq[i]
x_sub <- reclamos[1:k]
betaMM_path[i] <- 1 + sqrt(1 + (mean(x_sub)^2 / var(x_sub)))
}
df_cons <- data.frame(n = n_seq, betaMM = betaMM_path)
library(ggplot2)
ggplot(df_cons, aes(x = n, y = betaMM)) +
geom_line(color = "blue", linewidth = 1) +
geom_hline(yintercept = beta_true, linetype = "dashed", color = "red", linewidth = 1) +
labs(title = "Consistencia del Estimador MM para β",
subtitle = "Convergencia en probabilidad al valor verdadero al aumentar n",
x = "Tamaño de muestra (n)",
y = "Estimación de β") +
theme_minimal()
# Usamos la base de datos 'reclamos' generada en la sección 1.1
n_obs <- length(reclamos) # n = 1000
x_min_obs <- min(reclamos)
# Cálculo del estadístico T
T_obs <- sum(log(reclamos / x_min_obs))
# Cálculo del Estimador 5 (EIVUM)
beta_eivum_val <- (n_obs - 2) / T_obs
print(paste("Valor Verdadero Beta:", beta_true))
print(paste("Estimación EIVUM:", round(beta_eivum_val, 5)))
print(paste("Diferencia (Sesgo muestral):", round(beta_eivum_val - beta_true, 5)))
# =============================================================================
# GRÁFICO: COMPARACIÓN DE EFICIENCIA (EIVUM vs EMV)
# =============================================================================
set.seed(123)
n_sim <- 50  # Usamos n pequeño para notar diferencias visuales
N_rep <- 5000
sim_eivum <- numeric(N_rep)
sim_emv <- numeric(N_rep)
for(i in 1:N_rep){
# Generar Pareto
u <- runif(n_sim)
x <- alpha_true / (1 - u)^(1/beta_true)
T_val <- sum(log(x / min(x)))
sim_eivum[i] <- (n_sim - 2) / T_val
sim_emv[i] <- n_sim / T_val
}
df_eff <- data.frame(
Valor = c(sim_eivum, sim_emv),
Estimador = rep(c("EIVUM (Insesgado)", "EMV (Sesgado)"), each = N_rep)
)
library(ggplot2)
ggplot(df_eff, aes(x = Valor, fill = Estimador)) +
geom_density(alpha = 0.5) +
geom_vline(xintercept = beta_true, linetype = "dashed", size = 1) +
scale_fill_manual(values = c("green3", "tomato")) +
labs(title = "Comparación de Eficiencia: EIVUM vs EMV",
subtitle = "El EIVUM (Verde) está centrado en 3. El EMV (Rojo) está desplazado a la derecha.",
x = "Estimación de Beta", y = "Densidad") +
theme_minimal() +
xlim(1.5, 5)
# =============================================================================
# GRÁFICO: CONSISTENCIA DEL EIVUM (CONVERGENCIA)
# =============================================================================
# Usamos la base grande 'reclamos' (n=1000)
n_seq <- seq(10, 1000, by = 5)
est_trayectoria <- numeric(length(n_seq))
for(i in 1:length(n_seq)){
k <- n_seq[i]
sub_x <- reclamos[1:k]
T_sub <- sum(log(sub_x / min(sub_x)))
est_trayectoria[i] <- (k - 2) / T_sub
}
df_cons <- data.frame(n = n_seq, Estimacion = est_trayectoria)
ggplot(df_cons, aes(x = n, y = Estimacion)) +
geom_line(color = "blue", size = 0.8) +
geom_hline(yintercept = beta_true, color = "red", linetype = "dashed", size = 1) +
labs(title = "Consistencia del Estimador 5 (EIVUM)",
subtitle = "Convergencia al valor verdadero (3) al aumentar la muestra",
x = "Tamaño de muestra (n)", y = "Valor Estimado") +
theme_minimal() +
ylim(2.5, 3.5)
# ==============================================================================
# CÁLCULO DEL INTERVALO DE CONFIANZA EXACTO PARA BETA
# Método del Pivote (Chi-Cuadrado)
# ==============================================================================
# 1. Configuración
# Usamos la variable 'reclamos' que ya existe en el entorno
datos_analisis <- reclamos
n <- length(datos_analisis)
nivel_confianza <- 0.95
alfa <- 1 - nivel_confianza
# 2. Cálculo de la Estadística Suficiente (T)
x_min <- min(datos_analisis)
T_stat <- sum(log(datos_analisis / x_min))
# 3. Valores Críticos de la Chi-Cuadrado
# El pivote es Q = 2*beta*T ~ Chi^2(gl = 2(n-1))
gl <- 2 * (n - 1)
chi_inf <- qchisq(alfa / 2, df = gl)      # Cola izquierda
chi_sup <- qchisq(1 - alfa / 2, df = gl)  # Cola derecha
# 4. Construcción del Intervalo
# Fórmula: [ Chi_Inf / 2T  ;  Chi_Sup / 2T ]
Limite_Inferior <- chi_inf / (2 * T_stat)
Limite_Superior <- chi_sup / (2 * T_stat)
# 5. Reporte de Resultados
cat(
"INTERVALO DE CONFIANZA EXACTO PARA BETA\n\n",
"Tamaño de muestra (n): ", n, "\n",
"Estadística T: ", round(T_stat, 4), "\n",
"Grados de Libertad: ", gl, "\n\n",
"Límite Inferior: ", round(Limite_Inferior, 5), "\n",
"Límite Superior: ", round(Limite_Superior, 5), "\n"
)
